<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SF 911 Visualization</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    .cursor-hidden {
      cursor: none;
    }
  </style>
</head>
<body>
  <script>
    /* 
     * SF 911 Visualization - Working Version
     * Based on the smoke particles example with soft pastel colors
     */
    
    // Global variables
    let mic;
    let particleSystems = [];
    let callTypes = {};
    
    // Performance settings
    let maxParticleSystems = 15;
    let maxParticlesPerSystem = 60; // CHANGED: Increased from 40 for more visible smoke
    
    // SF map boundaries (for realism)
    const SF_BOUNDS = {
      min_lon: -122.52,
      max_lon: -122.36,
      min_lat: 37.70,
      max_lat: 37.83
    };
    
    function setup() {
      createCanvas(windowWidth, windowHeight);
      background(0);
      
      // Setup microphone
      mic = new p5.AudioIn();
      mic.start();
      
      // Create initial particle systems
      createInitialParticleSystems();
      
      // Hide cursor after inactivity
      setTimeout(() => {
        document.body.classList.add('cursor-hidden');
      }, 3000);
    }
    
    function draw() {
      // CHANGED: More transparent background to show more trails
      background(0, 18); // Reduced opacity from 25 to 18
      
      // Update wind based on mic input - ADJUSTED: Less horizontal movement
      let micLevel = mic.getLevel() || 0.01;
      let dx = map(micLevel, 0, 0.1, -0.02, 0.02); // REDUCED from (-0.05, 0.05) to make less horizontal drift
      
      // ADDED: More vertical movement from audio to balance the reduced horizontal drift
      let dy = map(micLevel, 0, 0.1, -0.01, -0.04); // Add some upward movement based on audio
      
      let wind = createVector(dx, dy);
      
      // CHANGED: Less frequent creation of new systems to avoid too many blinking effects
      if (frameCount % 120 === 0 && particleSystems.length < maxParticleSystems) { // Changed from 60 to 120
        addRandomParticleSystem();
      }
      
      // Run all particle systems
      for (let i = particleSystems.length - 1; i >= 0; i--) {
        let ps = particleSystems[i];
        ps.applyForce(wind);
        ps.run();
        
        // CHANGED: More consistent particle emission (less variance between priorities)
        // This helps prevent the "blinking" effect caused by intermittent emission
        let particleRate = 2; // Default rate increased
        if (ps.priority === 'A') particleRate = 3;
        else if (ps.priority === 'B') particleRate = 2;
        else particleRate = 2; // Even priority C gets consistent emission
        
        // Only add particles if under the per-system limit
        if (ps.particles.length < maxParticlesPerSystem) {
          for (let j = 0; j < particleRate; j++) {
            ps.addParticle();
          }
        }
        
        // CHANGED: Check if we've reached the onscene time
        if (ps.hasReachedOnScene()) {
          particleSystems.splice(i, 1);
        }
      }
      
      // Display debug info if enabled
      displayDebugInfo();
    }
    
    function createInitialParticleSystems() {
      // Create several initial particle systems
      for (let i = 0; i < 10; i++) {
        addRandomParticleSystem();
      }
    }
    
    function addRandomParticleSystem() {
      // Random position on screen
      let x = random(width);
      let y = random(height);
      
      // Call types for coloring
      let callTypeList = ["246", "415", "602", "915", "917", "219"];
      let callType = random(callTypeList);
      
      // Priority levels
      let priorityList = ['A', 'B', 'C'];
      let priority = random(priorityList);
      
      // Create new particle system
      let ps = new ParticleSystem(createVector(x, y));
      ps.callType = callType;
      ps.priority = priority;
      
      // ADDED: Generate dispatch and onscene times
      // Current frame count becomes dispatch time
      ps.dispatchTime = frameCount;
      
      // Set onscene time based on priority (A = fast response, C = slower)
      if (priority === 'A') {
        ps.onSceneTime = ps.dispatchTime + random(300, 500); // Higher priority calls get faster response
      } else if (priority === 'B') {
        ps.onSceneTime = ps.dispatchTime + random(500, 700);
      } else {
        ps.onSceneTime = ps.dispatchTime + random(700, 900); // Lower priority calls wait longer
      }
      
      particleSystems.push(ps);
    }
    
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
    
    // ADDED: Display debug info when holding 'D' key
    function keyPressed() {
      // Space to pause/play
      if (key === ' ') {
        noLoop();
      } else if (key === 'r' || key === 'R') {
        loop();
      }
      
      // Hold 'D' key to show debug info (current frame count and active particle systems)
      if (key === 'd' || key === 'D') {
        showDebugInfo = true;
      }
    }
    
    function keyReleased() {
      if (key === 'd' || key === 'D') {
        showDebugInfo = false;
      }
    }
    
    // Optional debug display function
    let showDebugInfo = false;
    
    function displayDebugInfo() {
      if (!showDebugInfo) return;
      
      fill(255);
      textSize(14);
      textAlign(LEFT, TOP);
      text("Frame: " + frameCount, 10, 10);
      text("Active Systems: " + particleSystems.length, 10, 30);
      
      // Display info for each particle system
      let y = 50;
      for (let i = 0; i < min(particleSystems.length, 10); i++) {
        let ps = particleSystems[i];
        text("System " + i + ": " + ps.callType + " (Priority " + ps.priority + ")", 10, y);
        text("  Dispatch: " + ps.dispatchTime + ", OnScene: " + ps.onSceneTime, 10, y + 20);
        text("  Remaining: " + (ps.onSceneTime - frameCount) + " frames", 10, y + 40);
        y += 60;
      }
    }
    
    function getColorForCallType(callTypeCode) {
      // Pastel color palette
      switch(callTypeCode) {
        case "246": // SHOOTING
          return color(255, 182, 193); // Light pink
        case "917": // SHOTS FIRED
          return color(255, 218, 185); // Peach
        case "219": // ROBBERY
          return color(255, 255, 224); // Light yellow
        case "415": // DISTURBING THE PEACE
          return color(204, 255, 204); // Mint green
        case "602": // TRESPASSING
          return color(173, 216, 230); // Light blue
        case "915": // SUSPICIOUS PERSON
          return color(221, 160, 221); // Plum
        default:
          return color(230, 230, 250); // Lavender
      }
    }
    
    //========= PARTICLE SYSTEM CLASS ===========
    let ParticleSystem = function(origin) {
      this.origin = origin.copy();
      this.particles = [];
      this.callType = "unknown";
      this.priority = "C";
      this.dispatchTime = 0;
      this.onSceneTime = 0;
      this.age = 0;
      
      // ADDED: Initial burst of particles to prevent empty-looking start
      this.initialParticles = 20; // Create some particles immediately
    };
    
    ParticleSystem.prototype.run = function() {
      this.age++;
      
      // ADDED: Create initial burst of particles when system is new
      if (this.age === 1 && this.initialParticles > 0) {
        for (let i = 0; i < this.initialParticles; i++) {
          this.addParticle();
        }
      }
      
      let len = this.particles.length;
      for (let i = len - 1; i >= 0; i--) {
        let particle = this.particles[i];
        particle.callType = this.callType; // Pass call type for coloring
        particle.run();
        
        if (particle.isDead()) {
          this.particles.splice(i, 1);
        }
      }
    };
    
    ParticleSystem.prototype.applyForce = function(dir) {
      let len = this.particles.length;
      for(let i = 0; i < len; ++i){
        this.particles[i].applyForce(dir);
      }
    };
    
    ParticleSystem.prototype.addParticle = function() {
      // CHANGED: Add slight position variation to each particle's starting position
      let offset = createVector(random(-5, 5), random(-5, 5));
      let startPos = p5.Vector.add(this.origin, offset);
      
      this.particles.push(new Particle(startPos, this.callType));
    };
    
    // CHANGED: Now checking if we've reached the onScene time instead of using age/lifespan
    ParticleSystem.prototype.hasReachedOnScene = function() {
      return frameCount >= this.onSceneTime;
    };
    
    //========= PARTICLE CLASS ===========
    // CHANGED: Particle constructor for better smoke effect
    let Particle = function (pos, callType) {
      this.loc = pos.copy();
      
      // Adjusted movement - less horizontal drift
      let vx = randomGaussian() * 0.15; // Reduced from 0.25 to decrease horizontal movement
      let vy = randomGaussian() * 0.3 - 0.65; // Modified vertical movement (more upward)
      
      this.vel = createVector(vx, vy);
      this.acc = createVector();
      
      // CHANGED: More consistent lifespan with less variance to prevent blinking effect
      this.lifespan = random(120, 140); // Small range instead of fixed value
      
      this.callType = callType || "unknown";
      this.radius = random(6, 15); // CHANGED: Smaller radius range (was 10-20)
      
      // ADDED: Variable to track opacity consistency
      this.opacityMultiplier = random(0.9, 1.1); // Slight random variation per particle
    };
    
    Particle.prototype.run = function() {
      this.update();
      this.render();
    };
    
    // CHANGED: Completely revised render function for more visible smoke effect
    Particle.prototype.render = function() {
      // Apply color based on call type
      let particleColor = getColorForCallType(this.callType);
      
      // Calculate size based on lifespan - SMOOTHER TRANSITION
      let lifeRatio = this.lifespan / 130.0;  // Normalize lifespan
      let size = map(lifeRatio, 0, 1, 0, 1) * this.radius;
      
      // CHANGED: Smoother fade-in/fade-out to prevent blinking
      let alpha = 255;
      if (lifeRatio > 0.9) {
        // Fade in during first 10% of life
        alpha = map(lifeRatio, 1, 0.9, 0, 255);
      } else if (lifeRatio < 0.2) {
        // Fade out during last 20% of life
        alpha = map(lifeRatio, 0, 0.2, 0, 255);
      }
      
      // Apply individual particle's opacity variation
      alpha *= this.opacityMultiplier;
      
      // Draw soft circle
      noStroke();
      
      // More subtle outer glow - fewer layers, less opacity
      for (let i = 3; i > 0; i--) {
        // Reduced opacity for glow layers, using the smooth alpha transition
        let layerAlpha = (alpha * 0.15) * (i / 3);
        fill(red(particleColor), green(particleColor), blue(particleColor), layerAlpha);
        // Smaller size multiplier for outer layers
        ellipse(this.loc.x, this.loc.y, size * (i * 0.8), size * (i * 0.8));
      }
      
      // Smaller, more defined core
      fill(red(particleColor), green(particleColor), blue(particleColor), alpha * 0.7);
      ellipse(this.loc.x, this.loc.y, size * 0.6, size * 0.6);
    };
    
    Particle.prototype.applyForce = function(f) {
      this.acc.add(f);
    };
    
    Particle.prototype.isDead = function () {
      if (this.lifespan <= 0.0) {
        return true;
      } else {
        return false;
      }
    };
    
    // CHANGED: Slower fade-out
    Particle.prototype.update = function() {
      this.vel.add(this.acc);
      this.loc.add(this.vel);
      this.lifespan -= 2.2; // CHANGED: Slower fade-out (was 3.5)
      this.acc.mult(0);
    };
  </script>
</body>
</html>